/**
 * sampler.js is a plugin to display code samples from specially-formatted
 * source files in reveal.js slides.
 *
 * @namespace Sampler
 */
'use strict';

/**
 * @typedef Sampler.PluginConfiguration
 * @property {boolean} [removeIndentation] - remove indentation (un-indent source snippet)
 * @property {(boolean|'original')} [lineNumbers] - show line numbers
 * @property {(string|string[])} [skip] - skip specific lines by time (delimiter)
 * @property {string} [proxyURL] - fetch source files using a proxy script
 * @property {Object.<string, Sampler.TokenPatterns>} [patterns] - language specific patterns
 */

/**
 * @typedef HighlightJS.HighlightOptions
 * @property {string} language
 * @property {boolean} ignoreIllegals
 */

/**
 * @typedef HighlightJS
 * @property {function} highlight
 */

/**
 * @typedef RevealJSDeck
 * @property {function} getConfig
 * @property {function} getPlugin
 */

/**
 * @memberof Sampler
 */
class SamplerPlugin {

    id = "Sampler";

    // noinspection JSUnusedGlobalSymbols
    /**
     *
     * @param {RevealJSDeck} deck
     */
    init(deck) {
        const configuration = deck.getConfig().sampler || {};
        const options = {
            removeIndentation: !!configuration.removeIndentation,
            lineNumbers: [true, 'original'].indexOf(configuration.lineNumbers) !== -1
                ? configuration.lineNumbers : false,
            skip: configuration.skip instanceof Array
                ? configuration.skip : (configuration.skip || '').split(/[,\s]+/),
            proxyURL: configuration.proxyURL || '',
            patterns: configuration.patterns || null
        };
        this.addStyles();
        this.addSamples(options, this.getHighlightJS(deck));
    }

    getHighlightJS(deck) {
        return window.hljs || deck.getPlugin('highlight')?.hljs || undefined;
    }

    addStyles() {
        // add some CSS to make the line numbers visible
        const style =
            "[data-sample] [data-line-number]:before {\n" +
            "   content: attr(data-line-number) ': ';\n" +
            "}";
        const styleNode = document.createElement('style');
        styleNode.setAttribute('type', 'text/css');
        styleNode.appendChild(document.createTextNode(style));
        document.head.appendChild(styleNode);
    }

    /**
     *
     * @param {Sampler.PluginConfiguration} options
     * @param {HighlightJS} [highlightJS]
     */
    addSamples(options, highlightJS ) {
        const files = new Files(new TokenMatcher(options.patterns));
        const elements = document.querySelectorAll('[data-sample]');
        elements.forEach(
            /**
             *
             * @param {HTMLElement} element
             */
            (element) => {
                const slug = element.getAttribute('data-sample').match(/([^#]+)(?:#(.+))?/);
                const url = options.proxyURL + slug[1];
                const selector = slug[2] || '';

                // Add the right `language-xyz` class to the code block, if required.
                let language = this.getLanguageFromURL(url);
                let status = [...element.classList].reduce(
                    (carry, key) => {
                       const [prefix, value] = key.split('-');
                       if (prefix === 'language' || prefix === 'lang') {
                           carry.classes.push(key);
                           if (value !== 'undefined') {
                               carry.language = value;
                           }
                       }
                       return carry;
                    },
                    {
                        classes: [],
                        language
                    }
                );
                status.classes.forEach(
                    (name) => element.classList.remove(name)
                );
                element.classList.add('language-' + status.language);

                files.fetch(
                    url,
                    language,
                    function (sampleFile) {
                        const sample = Sample.createFromFile(sampleFile, selector, status.language);
                        const attributes = {
                            mark: element.getAttribute('data-sample-mark') || '',
                            indent: element.getAttribute('data-sample-indent'),
                            skip: (element.getAttribute('data-sample-skip') || options.skip.join(',')),
                            lineNumbers: element.getAttribute('data-sample-line-numbers')
                        };

                        sample.appendTo(
                            element,
                            {
                                // marked lines selector
                                marked: attributes.mark,
                                // skip lines
                                skip: {
                                    // (sample start/end, delimiter lines)
                                    delimiters: attributes.skip.match(/\bdelimiters?\b/),
                                    // expand ranges to line index array
                                    lines: Sample.parseSelectorToLineIndex(attributes.skip)
                                },
                                // indentation behaviour defined by attribute or global option
                                removeIndentation:
                                    attributes.indent === 'remove' ||
                                    (options.removeIndentation && attributes.indent !== 'keep'),
                                // line numbers behaviour
                                lineNumbers: attributes.lineNumbers || options.lineNumbers
                            },
                            highlightJS
                        ).catch();
                    }
                );
            }
        );
    }

    getLanguageFromURL(url) {
        const map = {
            rb: "ruby"
        }
        const extension = url.split('.').pop().toLowerCase();
        return map[extension] || extension;
    }
}

/**
 * @typedef Sampler.TokenPatterns
 * @property {RegExp} [start] - sample start delimiter pattern
 * @property {RegExp} [end] - sample end delimiter pattern
 * @property {RegExp} [end_named] - sample named end delimiter pattern
 * @property {RegExp} [skip] - skip line pattern
 * @property {RegExp} [mark] - mark line pattern
 */

/**
 * @typedef {number} Sampler.TokenMatcher.TOKEN
 */

/**
 * @callback Sampler.Files.FetchSuccess
 * @param {Sampler.File} file
 */


/**
 *  Match line tokens with a generic and/or language specific patterns
 * @memberof Sampler
 */
class TokenMatcher {

    /**
     * Token identifiers
     *
     * @readonly
     * @enum {Sampler.TokenMatcher.TOKEN}
     */
    static TOKEN = {
        LINE: 0,
        START_NAMED: 1,
        END: 2,
        END_NAMED: 3,
        SKIP_LINE: 4,
        MARK_LINE: 5
    };

    /**
     * Map token option names to token identifiers
     *
     * @see Sampler.PluginConfiguration
     *
     * @readonly
     * @enum {Sampler.TokenMatcher.TOKEN}
     */
    static PATTERN_NAMES = {
        start: TokenMatcher.TOKEN.START_NAMED,
        end_named: TokenMatcher.TOKEN.END_NAMED,
        end: TokenMatcher.TOKEN.END,
        skip: TokenMatcher.TOKEN.SKIP_LINE,
        mark: TokenMatcher.TOKEN.MARK_LINE
    };

    /**
     * @type {Object.<string, Sampler.TokenPatterns>}
     * @private
     */
    _patterns = {
        generic: {
            start: /^[/*#\s]*sample\(([^)\r\n]+)\)/,
            end_named: /^[/*#\s]*end-sample\(([^)\r\n]+)\)/,
            end: /^[/*#\s]*end-sample/,
            skip: /\bskip-sample\b/,
            mark: /(\s*(\/\/|#)\s*mark-sample\s*$)|(\s*\/\*\s*mark-sample\s*\*\/(\s*$))/
        },
        xml: {
            start: /^\s*<!--\s*sample\(([^)\r\n]+)\)/,
            end_named: /^\s*<!--\s*end-sample\(([^)\r\n]+)\)/,
            end: /^\s*<!--\s*end-sample/,
            skip: /<!--\s*skip-sample\s*-->/,
            mark: /\s*(<!--\s*mark-sample\s*-->\s*$)/
        }
    };

    /**
     * @param {Object.<string, Sampler.TokenPatterns>} patterns
     */
    constructor(patterns = {}) {
        this._patterns.html = this._patterns.xml;
        if (patterns instanceof Object) {
            for (let language in patterns) {
                for (let patternName in TokenMatcher.PATTERN_NAMES) {
                    if (!TokenMatcher.PATTERN_NAMES.hasOwnProperty(patternName)) {
                        continue;
                    }
                    if (patterns[language][patternName] instanceof RegExp) {
                        this._patterns[language][name] = RegExp;
                    } else {
                        console.log('Ignored invalid pattern option for: ' + language + ':' + patternName);
                    }
                }
            }
        }
    };


    /**
     * @param {string} name
     * @param {string} language
     * @returns {RegExp}
     */
    getPattern(name, language) {
        if (this._patterns[language] && this._patterns[language][name]) {
            return this._patterns[language][name];
        }
        if (this._patterns.generic && this._patterns.generic[name]) {
            return this._patterns.generic[name];
        }
        throw "Can not find pattern for " + language + ":" + name;
    };

    /**
     * @param {string} subject
     * @param {string} language
     * @returns {?{type:string, match:{}, pattern: RegExp}}
     */
    identify(subject, language) {
        let token, pattern, match;
        for (let patternName in TokenMatcher.PATTERN_NAMES) {
            if (!TokenMatcher.PATTERN_NAMES.hasOwnProperty(patternName)) {
                continue;
            }
            token = TokenMatcher.PATTERN_NAMES[patternName];
            pattern = this.getPattern(patternName, language);
            match = subject.match(pattern);
            if (match) {
                return {
                    type: token,
                    match: match,
                    pattern: pattern
                };
            }
        }
        return null;
    };
}


/**
 * @memberof Sampler
 */
class Line {

    /**
     * @param {Number} lineNumber
     * @param {string} text
     * @param {Sampler.TokenMatcher.TOKEN} type
     */
    constructor(lineNumber, text, type) {
        /**
         * @type {Number}
         */
        this.lineNumber = lineNumber;
        /**
         * @type {string}
         */
        this.text = text || '';
        /**
         * @type {Sampler.TokenMatcher.TOKEN}
         */
        this.type = type || TokenMatcher.TOKEN.LINE;
    }

}


/**
 * SampleFile provides access to the lines and named samples in a file
 *
 * @memberof Sampler
 */
class File {

    /**
     * @private
     * @type {Sampler.Line[]}
     */
    _lines = [];

    /**
     * @private
     * @type {Object.<string, Sampler.Line[]>}
     */
    _samples = {};

    /**
     * @param {string} content
     * @param {Sampler.TokenMatcher} matcher
     * @param {string} language
     */
    constructor(content, matcher, language) {
        const lines = content.split(/\r?\n/);
        let line, currentSnippets = [], token, i, c, k;
        let lineType, lineText;

        for (i = 0, c = lines.length; i < c; i++) {
            lineType = TokenMatcher.TOKEN.LINE;
            lineText = lines[i];
            if (i === c - 1 && lineText === '') {
                break;
            }
            token = matcher.identify(lineText, language);
            if (token) {
                lineType = token.type;
                switch (token.type) {
                    case TokenMatcher.TOKEN.START_NAMED :
                        currentSnippets.push(token.match[1]);
                        break;
                    case TokenMatcher.TOKEN.END_NAMED :
                        for (k = currentSnippets.length - 1; k >= 0; k--) {
                            if (currentSnippets[k] === token.match[1]) {
                                currentSnippets.splice(k, 1);
                            }
                        }
                        break;
                    case TokenMatcher.TOKEN.END :
                        if (currentSnippets.length > 0) {
                            currentSnippets.pop();
                        }
                        break;
                    case TokenMatcher.TOKEN.MARK_LINE :
                        lineText = lineText.replace(token.pattern, '');
                        break;
                }
            }
            this._lines.push(
                line = new Line(i + 1, lineText, lineType)
            );
            if (lineType === TokenMatcher.TOKEN.LINE || lineType === TokenMatcher.TOKEN.MARK_LINE) {
                currentSnippets
                    .filter(
                        function (value, index, self) {
                            return self.indexOf(value) === index;
                        }
                    )
                    .forEach(
                        function (index, line) {
                            return function (name) {
                                if (!this._samples.hasOwnProperty(name)) {
                                    this._samples[name] = [];
                                }
                                this._samples[name].push(line);
                            }.bind(this);
                        }.bind(this)(i, line)
                    )
            }
        }
    }

    /**
     * Get an array of lines
     *
     * @param {string} name - sample name
     * @returns {?Sampler.Line[]} - array of sample lines
     */
    getSample(name) {
        return this._samples[name] || null;
    };

    /**
     * Get an array of lines specified by start index and length. If
     * length is not provided it will return all following lines.
     *
     * @param {number} [start=0] - start index
     * @param {number} [length] - amount of lines
     * @returns {Sampler.Line[]}
     */
    getLines(start, length) {
        start = start > 0 ? start : 0;
        if (typeof length === 'undefined') {
            return this._lines.slice(start);
        }
        return this._lines.slice(start, start + length);
    }
}

/**
 * Fetches the files, creates and returns SampleFile objects. It keeps
 * track of requests so that each file is requested once only.
 *
 * @memberof Sampler
 */
class Files {
    /**
     * @private
     * @type {Sampler.TokenMatcher}
     */
    _matcher;
    /**
     * @private
     * @type {Object.<string, Sampler.File>}
     */
    _files = {};
    /**
     * @private
     * @type {(boolean|Object.<string, {xhr: XMLHttpRequest, success: Sampler.Files.FetchSuccess[]}>)}
     */
    _requests = {};

    constructor(matcher) {
        this._matcher = matcher;
    };


    /**
     * Fetch file and execute callback with created SampleFile object
     *
     * @param {string} url
     * @param {string} language
     * @param {Sampler.Files.FetchSuccess} success
     */
    fetch(url, language, success) {
        let file, request;
        file = this._files[url] || null;
        if (file instanceof File) {
            // found existing file object, execute callback
            success(file);
        }
        request = this._requests[url] || null;
        if (request instanceof Object) {
            // found a request. store callback
            request.success.push(success);
        } else if (request === null) {
            // create and store a new request
            this._requests[url] = request = {
                xhr: new XMLHttpRequest(),
                success: [success]
            };
            request.xhr.onreadystatechange = function (url, language, request) {
                return function () {
                    if (request.xhr.readyState === XMLHttpRequest.DONE) {
                        if (
                            (request.xhr.status >= 200 && request.xhr.status < 300) ||
                            (request.xhr.status === 0 && request.xhr.responseText !== '')
                        ) {
                            this._files[url] = file = new File(
                                request.xhr.responseText, this._matcher, language
                            );
                            request.success.forEach(
                                function (file) {
                                    return function (success) {
                                        success(file);
                                    }
                                }(file)
                            );
                            this._requests[url] = true;
                        } else {
                            console.log('Failed to get file: ' + url);
                            this._requests[url] = false;
                        }
                    }
                }.bind(this)
            }.bind(this)(url, language, request);
            request.xhr.open("GET", url);
            try {
                request.xhr.send();
            } catch (e) {
                console.log('Error requesting file: ' + url);
            }
        }
    }
}


/**
 * @memberof Sampler
 */
class LineRange {

    /**
     * @type {number}
     */
    start = 0;

    /**
     * @type {number}
     */
    length = 0;

    /**
     * @param {number} start
     * @param {number} length
     */
    constructor(start, length) {
        this.start = start;
        this.length = length;
    }
}

/**
 * @memberof Sampler
 */
class NamedRange {

    /**
     * @type {string}
     */
    name = '';

    /**
     * @param {string} name
     */
    constructor(name) {
        this.name = name;
    }
}

/**
 * @memberof Sampler
 */
class Sample {

    constructor(language) {
        this._language = language;
        /** @private */
        this._lines = [];
    };

    /**
     * Create a Sample from a file using a selector
     * @param {Sampler.File} file
     * @param {string} selector
     * @returns {Sampler.Sample}
     */
    static createFromFile(file, selector, language) {
        const sample = new Sample(language);
        if (selector) {
            const ranges = Sample.parseSelector(selector);
            ranges.forEach(
                (range) => {
                    let lines = null;
                    if (range instanceof LineRange) {
                        lines = file.getLines(range.start, range.length);
                    } else if (range instanceof NamedRange) {
                        lines = file.getSample(range.name);
                    }
                    if (lines) {
                        sample.add(lines);
                    }
                }
            );
        } else {
            sample.add(file.getLines() || []);
        }
        return sample;
    };

    /**
     * Parse the selector in a list of range objects
     * @param {string} selector
     * @returns {Array.<Sampler.LineRange|Sampler.NamedRange>}
     */
    static parseSelector = function (selector) {
        const ranges = selector.split(",") || [];
        let range, start, end;
        const result = [];
        for (let i = 0, c = ranges.length; i < c; i++) {
            // try to match a line number or range
            range = ranges[i].match(/^\s*(\d+)(?:-(\d+))?\s*$/);
            if (range) {
                start = parseInt(range[1]) || 0;
                end = parseInt(range[2]) || start;
                result.push(new LineRange(start - 1, end - start + 1));
            } else {
                // otherwise treat it as a name
                range = ranges[i].trim();
                if (range !== '') {
                    result.push(new NamedRange(range));
                }
            }
        }
        return result.length > 0 ? result : null;
    };

    /**
     * Expands line numbers and ranges to an object with the line index as key.
     *
     *     3-6,12 => {2: true, 3: true, 4: true, 5: true, 11: true}
     *
     * @param {string} selector
     * @returns {?Object.<number, boolean>}
     */
    static parseSelectorToLineIndex(selector) {
        const lines = {};
        const ranges = Sample.parseSelector(selector);
        if (ranges instanceof Array && ranges.length > 0) {
            for (let i = 0, c = ranges.length; i < c; i++) {
                if (ranges[i] instanceof LineRange) {
                    for (let x = 0; x < ranges[i].length; x++) {
                        lines[ranges[i].start + x] = true;
                    }
                }
            }
            return lines;
        }
        return null;
    };

    /**
     * @param {Sampler.Line[]} lines
     */
    add = function (lines) {
        this._lines.push.apply(
            this._lines,
            lines.filter(
                function (line) {
                    return line.type !== TokenMatcher.TOKEN.SKIP_LINE;
                }
            )
        );
    };

    /**
     * @param {boolean} skipDelimiters
     * @param {number[]} skipLines - skip lines by index
     * @returns {Sampler.Line[]}
     */
    getLines(skipDelimiters, skipLines) {
        let lines = this._lines;
        if (skipDelimiters) {
            lines = lines.filter(
                function (line) {
                    // skip delimiter lines if option is set
                    return !(
                        skipDelimiters &&
                        (
                            line.type === TokenMatcher.TOKEN.START_NAMED ||
                            line.type === TokenMatcher.TOKEN.END ||
                            line.type === TokenMatcher.TOKEN.END_NAMED
                        )
                    );
                }
            )
        }
        if (skipLines) {
            lines = lines.filter(
                function (line, index) {
                    // skip lines defined by index
                    return !skipLines[index];
                }
            )
        }
        return lines;
    };

    /**
     * @typedef Sampler.Sample.AppendOptions
     * @property {boolean} removeIndentation
     * @property {string} marked
     * @property {(boolean|number|'original')} lineNumbers
     * @property {Object} skip
     */


    /**
     * @param {string} value
     * @returns {string}
     */
    escapeHTML(value) {
        return value
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;');
    }

    /**
     * @param {HTMLElement} parentNode
     * @param {Sampler.Sample.AppendOptions} options
     * @param {HighlightJS} [highlightJS]
     * @returns {Promise<void>}
     */
    async appendTo(
        parentNode, options, highlightJS
    ) {
        let line, lineNode, previousLineNode, lineText = null;
        const document = parentNode.ownerDocument;
        const marked = Sample.parseSelectorToLineIndex(options.marked || '') || {};
        let lineNumberStart = parseInt(options.lineNumbers) || 0, lineNumberSize;
        const lines = this.getLines(options.skip.delimiters, options.skip.lines);
        const indentationOffset = (options.removeIndentation) ? this.getIndentationLength(lines) : 0;
        if (lines.length < 1) {
            return;
        }
        if (options.lineNumbers === true || options.lineNumbers === 'true' || options.lineNumbers === 'yes') {
            lineNumberStart = 1;
        }
        if (options.lineNumbers === 'original') {
            lineNumberSize = lines[lines.length - 1].lineNumber.toString().length;
        } else {
            lineNumberSize = (lineNumberStart + this._lines.length).toString().length;
        }
        parentNode.setAttribute('data-noescape', '');
        let content = undefined;
        if (highlightJS) {
            try {
                content = highlightJS.highlight(
                    lines.map((l) => l.text).join('\n'),
                    {language: this._language, ignoreIllegals: true}
                ).value.split('\n');
            } catch (e) {
            }
        }
        if (!content) {
           content = lines.map((l) => this.escapeHTML(l.text));
        }

        for (let i = 0, c = lines.length; i < c; i++) {
            line = lines[i];
            lineText = content[i].substring(indentationOffset);
            lineNode = parentNode.appendChild(document.createElement('span'));
            lineNode.setAttribute('class', 'line');
            if (options.lineNumbers === 'original') {
                // noinspection JSUnresolvedFunction
                lineNode.setAttribute('data-line-number', String(line.lineNumber).padStart(lineNumberSize));
            } else if (lineNumberStart > 0) {
                // noinspection JSUnresolvedFunction
                lineNode.setAttribute('data-line-number', String(lineNumberStart + i).padStart(lineNumberSize));
            }
            if (line.type === TokenMatcher.TOKEN.MARK_LINE || marked[i]) {
                lineNode
                    .appendChild(document.createElement('mark'))
                    .innerHTML = lineText;
            } else {
                lineNode.innerHTML = lineText;
            }
            if (previousLineNode) {
                previousLineNode.appendChild(document.createTextNode('\n'));
            }
            previousLineNode = lineNode;
        }
    };

    /**
     * Get the length of the shortest whitespace sequence at a line start
     *
     * @param {Sampler.Line[]} [lines]
     * @returns {number}
     */
    getIndentationLength(lines) {
        lines = lines instanceof Array ? lines : this._lines;
        return Math.min.apply(
            null,
            lines
                .filter(
                    function (line) {
                        return line.text.trim() !== '';
                    }
                )
                .map(
                    function (line) {
                        const indentation = line.text.match(/^[ \t]*(?=\S)/mg);
                        return indentation ? indentation[0].length : 0
                    }
                )
        ) || 0;
    }
}

export default (() => new SamplerPlugin());
